import 'package:cloud_firestore/cloud_firestore.dart';
import '../screens/chat_screen.dart'; // For SessionState enum

/// Represents a complete chat session with all messages and metadata
class ChatSession {
  final String id;
  final String token; // Simple token for URL access
  final String name;
  final String? autoGeneratedName;
  final List<String> topics;
  final List<ChatMessage> messages;
  final SessionState state;
  final Map<String, int>? finalScores;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isCompleted;
  final int messageCount;
  final DateTime? lastMessageAt;

  ChatSession({
    required this.id,
    required this.token,
    required this.name,
    this.autoGeneratedName,
    required this.topics,
    required this.messages,
    required this.state,
    this.finalScores,
    required this.createdAt,
    required this.updatedAt,
    required this.isCompleted,
    required this.messageCount,
    this.lastMessageAt,
  });

  /// Create a new chat session
  factory ChatSession.create({
    required String id,
    required List<String> topics,
    String? name,
    String? token,
  }) {
    final now = DateTime.now();
    return ChatSession(
      id: id,
      token: id, // Always use session ID as token
      name: name ?? 'New Chat Session',
      topics: topics,
      messages: [],
      state: SessionState.collectingTopics,
      createdAt: now,
      updatedAt: now,
      isCompleted: false,
      messageCount: 0,
    );
  }

  /// Create a copy with updated fields
  ChatSession copyWith({
    String? id,
    String? token,
    String? name,
    String? autoGeneratedName,
    List<String>? topics,
    List<ChatMessage>? messages,
    SessionState? state,
    Map<String, int>? finalScores,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isCompleted,
    int? messageCount,
    DateTime? lastMessageAt,
  }) {
    return ChatSession(
      id: id ?? this.id,
      token: token ?? this.token,
      name: name ?? this.name,
      autoGeneratedName: autoGeneratedName ?? this.autoGeneratedName,
      topics: topics ?? this.topics,
      messages: messages ?? this.messages,
      state: state ?? this.state,
      finalScores: finalScores ?? this.finalScores,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isCompleted: isCompleted ?? this.isCompleted,
      messageCount: messageCount ?? this.messageCount,
      lastMessageAt: lastMessageAt ?? this.lastMessageAt,
    );
  }

  /// Convert to Firestore document
  Map<String, dynamic> toFirestore() {
    return {
      'token': token,
      'name': name,
      'autoGeneratedName': autoGeneratedName,
      'topics': topics,
      'state': state.name,
      'finalScores': finalScores,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'isCompleted': isCompleted,
      'messageCount': messageCount,
      'lastMessageAt':
          lastMessageAt != null ? Timestamp.fromDate(lastMessageAt!) : null,
    };
  }

  /// Create from Firestore document with messages
  factory ChatSession.fromFirestore(
    DocumentSnapshot doc,
    List<ChatMessage> messages,
  ) {
    final data = doc.data() as Map<String, dynamic>;

    // Handle missing timestamp fields gracefully (older sessions might not have them)
    DateTime createdAt;
    if (data['createdAt'] != null) {
      createdAt = (data['createdAt'] as Timestamp).toDate();
    } else if (data['updatedAt'] != null) {
      // Fallback to updatedAt if createdAt is missing
      createdAt = (data['updatedAt'] as Timestamp).toDate();
    } else {
      // Last resort - use a very old date
      createdAt = DateTime(2020, 1, 1);
    }

    DateTime updatedAt;
    if (data['updatedAt'] != null) {
      updatedAt = (data['updatedAt'] as Timestamp).toDate();
    } else {
      // Fallback to createdAt or current time
      updatedAt = createdAt;
    }

    return ChatSession(
      id: doc.id,
      token: doc.id, // Always use document ID as token
      name: data['name'] ?? 'Untitled Session',
      autoGeneratedName: data['autoGeneratedName'],
      topics: List<String>.from(data['topics'] ?? []),
      messages: messages,
      state: _parseSessionState(data['state']),
      finalScores:
          data['finalScores'] != null
              ? Map<String, int>.from(data['finalScores'])
              : null,
      createdAt: createdAt,
      updatedAt: updatedAt,
      isCompleted: data['isCompleted'] ?? false,
      messageCount: data['messageCount'] ?? 0,
      lastMessageAt:
          data['lastMessageAt'] != null
              ? (data['lastMessageAt'] as Timestamp).toDate()
              : null,
    );
  }

  /// Parse session state from string
  static SessionState _parseSessionState(String? stateString) {
    switch (stateString) {
      case 'initial':
        return SessionState.initial;
      case 'selectingSessionType':
        return SessionState.selectingSessionType;
      case 'selectingDueTopics':
        return SessionState.selectingDueTopics;
      case 'collectingTopics':
        return SessionState.collectingTopics;
      case 'active':
        return SessionState.active;
      case 'completed':
        return SessionState.completed;
      case 'error':
        return SessionState.error;
      default:
        return SessionState.initial;
    }
  }
}

/// Lightweight summary of a chat session for listing purposes
class ChatSessionSummary {
  final String id;
  final String token;
  final String name;
  final String? autoGeneratedName;
  final List<String> topics;
  final DateTime createdAt;
  final DateTime? lastMessageAt;
  final bool isCompleted;
  final int messageCount;
  final SessionState state;

  ChatSessionSummary({
    required this.id,
    required this.token,
    required this.name,
    this.autoGeneratedName,
    required this.topics,
    required this.createdAt,
    this.lastMessageAt,
    required this.isCompleted,
    required this.messageCount,
    required this.state,
  });

  /// Create from Firestore document
  factory ChatSessionSummary.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    // Handle missing createdAt field gracefully (older sessions might not have it)
    DateTime createdAt;
    if (data['createdAt'] != null) {
      createdAt = (data['createdAt'] as Timestamp).toDate();
    } else if (data['updatedAt'] != null) {
      // Fallback to updatedAt if createdAt is missing
      createdAt = (data['updatedAt'] as Timestamp).toDate();
    } else {
      // Last resort - use a very old date so it sorts last
      createdAt = DateTime(2020, 1, 1);
    }

    // Extract fields defensively with better fallbacks
    final name =
        data['name'] as String? ??
        data['autoGeneratedName'] as String? ??
        'Session ${doc.id.substring(0, 8)}'; // Use doc ID as fallback

    final topics =
        data['topics'] != null
            ? List<String>.from(data['topics'] as List)
            : <String>['Untitled Topic']; // Provide fallback topic

    final messageCount =
        data['messageCount'] as int? ??
        (data['messages'] != null ? (data['messages'] as List).length : 0);

    return ChatSessionSummary(
      id: doc.id,
      token: doc.id, // Always use document ID as token
      name: name,
      autoGeneratedName: data['autoGeneratedName'] as String?,
      topics: topics,
      createdAt: createdAt,
      lastMessageAt:
          data['lastMessageAt'] != null
              ? (data['lastMessageAt'] as Timestamp).toDate()
              : null,
      isCompleted: data['isCompleted'] as bool? ?? false,
      messageCount: messageCount,
      state: ChatSession._parseSessionState(data['state'] as String?),
    );
  }

  /// Get display name (auto-generated if available, otherwise manual name)
  String get displayName => autoGeneratedName ?? name;

  /// Get status text for the session
  String get statusText {
    switch (state) {
      case SessionState.active:
        return 'In Progress';
      case SessionState.completed:
        return 'Completed';
      case SessionState.error:
        return 'Error';
      case SessionState.collectingTopics:
        return 'Setting up...';
      case SessionState.selectingSessionType:
        return 'Choosing type...';
      case SessionState.selectingDueTopics:
        return 'Selecting topics...';
      case SessionState.initial:
        return 'New';
    }
  }

  /// Get status color for the session
  String get statusColorType {
    switch (state) {
      case SessionState.active:
        return 'progress';
      case SessionState.completed:
        return 'success';
      case SessionState.error:
        return 'error';
      case SessionState.collectingTopics:
        return 'warning';
      case SessionState.selectingSessionType:
        return 'neutral';
      case SessionState.selectingDueTopics:
        return 'neutral';
      case SessionState.initial:
        return 'neutral';
    }
  }

  /// Get URL for this session
  String get sessionUrl => '/app/chat/$token';
}

import 'package:cloud_firestore/cloud_firestore.dart';
import 'dart:math';
import '../screens/chat_screen.dart'; // For SessionState enum

/// Represents a complete chat session with all messages and metadata
class ChatSession {
  final String id;
  final String token; // Simple token for URL access
  final String name;
  final String? autoGeneratedName;
  final List<String> topics;
  final List<ChatMessage> messages;
  final SessionState state;
  final Map<String, int>? finalScores;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isCompleted;
  final int messageCount;
  final DateTime? lastMessageAt;

  ChatSession({
    required this.id,
    required this.token,
    required this.name,
    this.autoGeneratedName,
    required this.topics,
    required this.messages,
    required this.state,
    this.finalScores,
    required this.createdAt,
    required this.updatedAt,
    required this.isCompleted,
    required this.messageCount,
    this.lastMessageAt,
  });

  /// Create a new chat session
  factory ChatSession.create({
    required String id,
    required List<String> topics,
    String? name,
    String? token,
  }) {
    final now = DateTime.now();
    return ChatSession(
      id: id,
      token: token ?? generateSessionToken(),
      name: name ?? 'New Chat Session',
      topics: topics,
      messages: [],
      state: SessionState.collectingTopics,
      createdAt: now,
      updatedAt: now,
      isCompleted: false,
      messageCount: 0,
    );
  }

  /// Create a copy with updated fields
  ChatSession copyWith({
    String? id,
    String? token,
    String? name,
    String? autoGeneratedName,
    List<String>? topics,
    List<ChatMessage>? messages,
    SessionState? state,
    Map<String, int>? finalScores,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isCompleted,
    int? messageCount,
    DateTime? lastMessageAt,
  }) {
    return ChatSession(
      id: id ?? this.id,
      token: token ?? this.token,
      name: name ?? this.name,
      autoGeneratedName: autoGeneratedName ?? this.autoGeneratedName,
      topics: topics ?? this.topics,
      messages: messages ?? this.messages,
      state: state ?? this.state,
      finalScores: finalScores ?? this.finalScores,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isCompleted: isCompleted ?? this.isCompleted,
      messageCount: messageCount ?? this.messageCount,
      lastMessageAt: lastMessageAt ?? this.lastMessageAt,
    );
  }

  /// Convert to Firestore document
  Map<String, dynamic> toFirestore() {
    return {
      'token': token,
      'name': name,
      'autoGeneratedName': autoGeneratedName,
      'topics': topics,
      'state': state.name,
      'finalScores': finalScores,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'isCompleted': isCompleted,
      'messageCount': messageCount,
      'lastMessageAt':
          lastMessageAt != null ? Timestamp.fromDate(lastMessageAt!) : null,
    };
  }

  /// Create from Firestore document
  factory ChatSession.fromFirestore(
    DocumentSnapshot doc,
    List<ChatMessage> messages,
  ) {
    final data = doc.data() as Map<String, dynamic>;

    return ChatSession(
      id: doc.id,
      token:
          data['token'] ??
          data['slug'] ?? // Backward compatibility with old slug field
          generateSessionToken(), // Fallback for very old sessions
      name: data['name'] ?? 'Untitled Session',
      autoGeneratedName: data['autoGeneratedName'],
      topics: List<String>.from(data['topics'] ?? []),
      messages: messages,
      state: _parseSessionState(data['state']),
      finalScores:
          data['finalScores'] != null
              ? Map<String, int>.from(data['finalScores'])
              : null,
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp).toDate(),
      isCompleted: data['isCompleted'] ?? false,
      messageCount: data['messageCount'] ?? 0,
      lastMessageAt:
          data['lastMessageAt'] != null
              ? (data['lastMessageAt'] as Timestamp).toDate()
              : null,
    );
  }

  /// Parse session state from string
  static SessionState _parseSessionState(String? stateString) {
    switch (stateString) {
      case 'initial':
        return SessionState.initial;
      case 'selectingSessionType':
        return SessionState.selectingSessionType;
      case 'selectingDueTopics':
        return SessionState.selectingDueTopics;
      case 'collectingTopics':
        return SessionState.collectingTopics;
      case 'active':
        return SessionState.active;
      case 'completed':
        return SessionState.completed;
      case 'error':
        return SessionState.error;
      default:
        return SessionState.initial;
    }
  }

  /// Generate a simple token for session URL access
  static String generateSessionToken() {
    // 12-character token with URL-safe alphabet (no ambiguous characters)
    const alphabet =
        'abcdefghjkmnpqrstvwxyz23456789-'; // Removed ambiguous: 0, o, O, 1, l, I, i
    const length = 12;

    final random = Random.secure();
    final buffer = StringBuffer();

    for (int i = 0; i < length; i++) {
      buffer.write(alphabet[random.nextInt(alphabet.length)]);
    }

    return buffer.toString();
  }

  /// Generate a unique token by checking against existing tokens
  static String generateUniqueToken(List<String> existingTokens) {
    String token;
    int attempts = 0;
    const maxAttempts = 10;

    do {
      token = generateSessionToken();
      attempts++;

      if (attempts > maxAttempts) {
        // This should be extremely rare with 12-character tokens
        throw Exception(
          'Failed to generate unique token after $maxAttempts attempts',
        );
      }
    } while (existingTokens.contains(token));

    return token;
  }
}

/// Lightweight summary of a chat session for listing purposes
class ChatSessionSummary {
  final String id;
  final String token;
  final String name;
  final String? autoGeneratedName;
  final List<String> topics;
  final DateTime createdAt;
  final DateTime? lastMessageAt;
  final bool isCompleted;
  final int messageCount;
  final SessionState state;

  ChatSessionSummary({
    required this.id,
    required this.token,
    required this.name,
    this.autoGeneratedName,
    required this.topics,
    required this.createdAt,
    this.lastMessageAt,
    required this.isCompleted,
    required this.messageCount,
    required this.state,
  });

  /// Create from Firestore document
  factory ChatSessionSummary.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    return ChatSessionSummary(
      id: doc.id,
      token:
          data['token'] ??
          data['slug'] ?? // Backward compatibility with old slug field
          ChatSession.generateSessionToken(), // Fallback
      name: data['name'] ?? 'Untitled Session',
      autoGeneratedName: data['autoGeneratedName'],
      topics: List<String>.from(data['topics'] ?? []),
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      lastMessageAt:
          data['lastMessageAt'] != null
              ? (data['lastMessageAt'] as Timestamp).toDate()
              : null,
      isCompleted: data['isCompleted'] ?? false,
      messageCount: data['messageCount'] ?? 0,
      state: ChatSession._parseSessionState(data['state']),
    );
  }

  /// Get display name (auto-generated if available, otherwise manual name)
  String get displayName => autoGeneratedName ?? name;

  /// Get status text for the session
  String get statusText {
    switch (state) {
      case SessionState.active:
        return 'In Progress';
      case SessionState.completed:
        return 'Completed';
      case SessionState.error:
        return 'Error';
      case SessionState.collectingTopics:
        return 'Setting up...';
      case SessionState.selectingSessionType:
        return 'Choosing type...';
      case SessionState.selectingDueTopics:
        return 'Selecting topics...';
      case SessionState.initial:
        return 'New';
    }
  }

  /// Get status color for the session
  String get statusColorType {
    switch (state) {
      case SessionState.active:
        return 'progress';
      case SessionState.completed:
        return 'success';
      case SessionState.error:
        return 'error';
      case SessionState.collectingTopics:
        return 'warning';
      case SessionState.selectingSessionType:
        return 'neutral';
      case SessionState.selectingDueTopics:
        return 'neutral';
      case SessionState.initial:
        return 'neutral';
    }
  }

  /// Get URL for this session
  String get sessionUrl => '/app/chat/$token';
}

import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/chat_session.dart';
import '../screens/chat_screen.dart'; // For ChatMessage
import '../services/logger_service.dart';

/// Service for managing chat sessions in Firebase
///
/// This service now writes to 'users/{userId}/sessions' collection, which is
/// shared with the backend. This unifies frontend UI state and backend
/// learning data.
class ChatSessionService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final _logger = getLogger('ChatSessionService');

  // Collection references
  CollectionReference<Map<String, dynamic>> _getUserSessionsCollection(
    String userId,
  ) {
    return _firestore.collection('users').doc(userId).collection('sessions');
  }

  CollectionReference<Map<String, dynamic>> _getSessionMessagesCollection(
    String userId,
    String sessionId,
  ) {
    return _getUserSessionsCollection(
      userId,
    ).doc(sessionId).collection('messages');
  }

  /// Save a chat session to Firebase
  Future<void> saveSession(String userId, ChatSession session) async {
    _logger.info('Saving session ${session.id} for user $userId');

    try {
      final batch = _firestore.batch();

      final sessionData = {
        'token': session.id,
        'name': session.name,
        'autoGeneratedName': session.autoGeneratedName,
        'topics': session.topics,
        'state': session.state.name,
        'finalScores': session.finalScores,
        'startedAt': Timestamp.fromDate(session.createdAt),
        'createdAt': Timestamp.fromDate(session.createdAt),
        'updatedAt': Timestamp.fromDate(session.updatedAt),
        'isCompleted': session.isCompleted,
        'messageCount': session.messageCount,
        'lastMessageAt':
            session.lastMessageAt != null
                ? Timestamp.fromDate(session.lastMessageAt!)
                : (session.messages.isNotEmpty
                    ? Timestamp.fromDate(session.messages.last.timestamp)
                    : null),
      };

      final sessionRef = _getUserSessionsCollection(userId).doc(session.id);
      batch.set(sessionRef, sessionData, SetOptions(merge: true));

      final messagesCollection = _getSessionMessagesCollection(
        userId,
        session.id,
      );

      final existingMessages = await messagesCollection.get();
      for (final doc in existingMessages.docs) {
        batch.delete(doc.reference);
      }

      for (int i = 0; i < session.messages.length; i++) {
        final message = session.messages[i];
        final messageData = {
          'text': message.text,
          'isUser': message.isUser,
          'isSystem': message.isSystem,
          'timestamp': Timestamp.fromDate(message.timestamp),
          'messageIndex': i,
        };
        final messageRef = messagesCollection.doc('msg_$i');
        batch.set(messageRef, messageData);
      }

      await batch.commit();
      _logger.info(
        'Successfully saved session ${session.id} with ${session.messages.length} messages',
      );
    } catch (e, stackTrace) {
      _logger.severe('Error saving session ${session.id}: $e', e, stackTrace);
      throw ChatSessionException('Failed to save session: $e');
    }
  }

  /// Load a specific chat session from Firestore
  Future<ChatSession?> loadSession(String userId, String sessionId) async {
    _logger.info('Loading session $sessionId for user $userId');
    try {
      final sessionDoc =
          await _getUserSessionsCollection(userId).doc(sessionId).get();

      if (!sessionDoc.exists) {
        _logger.warning('Session $sessionId not found');
        return null;
      }

      final messagesSnapshot =
          await _getSessionMessagesCollection(
            userId,
            sessionId,
          ).orderBy('messageIndex').get();

      final messages =
          messagesSnapshot.docs.map((doc) {
            final data = doc.data();
            return ChatMessage(
              text: data['text'],
              isUser: data['isUser'],
              isSystem: data['isSystem'] ?? false,
              timestamp: (data['timestamp'] as Timestamp).toDate(),
            );
          }).toList();

      final session = ChatSession.fromFirestore(sessionDoc, messages);
      _logger.info(
        'Successfully loaded session $sessionId with ${messages.length} messages',
      );
      return session;
    } catch (e, stackTrace) {
      _logger.severe('Error loading session $sessionId: $e', e, stackTrace);
      throw ChatSessionException('Failed to load session: $e');
    }
  }

  /// Get session history summaries for a user
  Future<List<ChatSessionSummary>> getSessionHistory(
    String userId, {
    int limit = 50,
    DocumentSnapshot? startAfter,
  }) async {
    _logger.info('Loading session history for user $userId (limit: $limit)');
    try {
      Query<Map<String, dynamic>> query = _getUserSessionsCollection(
        userId,
      ).orderBy('updatedAt', descending: true).limit(limit);

      if (startAfter != null) {
        query = query.startAfterDocument(startAfter);
      }

      var snapshot = await query.get();

      final sessions = <ChatSessionSummary>[];
      final sessionsNeedingRepair = <String>[];

      for (final doc in snapshot.docs) {
        try {
          final session = ChatSessionSummary.fromFirestore(doc);
          sessions.add(session);
        } catch (e) {
          _logger.warning('Error parsing session ${doc.id}: $e');
          sessionsNeedingRepair.add(doc.id);
        }
      }

      if (sessionsNeedingRepair.isNotEmpty) {
        _repairSessionsInBackground(userId, sessionsNeedingRepair);
      }

      _logger.info('Loaded ${sessions.length} session summaries');
      return sessions;
    } catch (e, stackTrace) {
      _logger.severe('Error loading session history: $e', e, stackTrace);
      throw ChatSessionException('Failed to load session history: $e');
    }
  }

  /// Delete a chat session and all its messages
  Future<void> deleteSession(String userId, String sessionId) async {
    _logger.info('Deleting session $sessionId for user $userId');
    try {
      final batch = _firestore.batch();
      final messagesSnapshot =
          await _getSessionMessagesCollection(userId, sessionId).get();
      for (final doc in messagesSnapshot.docs) {
        batch.delete(doc.reference);
      }
      final sessionRef = _getUserSessionsCollection(userId).doc(sessionId);
      batch.delete(sessionRef);
      await batch.commit();
      _logger.info('Successfully deleted session $sessionId');
    } catch (e, stackTrace) {
      _logger.severe('Error deleting session $sessionId: $e', e, stackTrace);
      throw ChatSessionException('Failed to delete session: $e');
    }
  }

  /// Update session name
  Future<void> updateSessionName(
    String userId,
    String sessionId,
    String newName, {
    bool isAutoGenerated = false,
  }) async {
    _logger.info('Updating session $sessionId name to: $newName');
    try {
      final updateData = <String, dynamic>{
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      };
      if (isAutoGenerated) {
        updateData['autoGeneratedName'] = newName;
      } else {
        updateData['name'] = newName;
      }
      await _getUserSessionsCollection(
        userId,
      ).doc(sessionId).update(updateData);
      _logger.info('Successfully updated session $sessionId name');
    } catch (e, stackTrace) {
      _logger.severe(
        'Error updating session $sessionId name: $e',
        e,
        stackTrace,
      );
      throw ChatSessionException('Failed to update session name: $e');
    }
  }

  /// Load a specific chat session from Firestore by token
  Future<ChatSession?> loadSessionByToken(String userId, String token) async {
    _logger.info('Loading session by token: $token for user $userId');
    try {
      final sessionDoc =
          await _getUserSessionsCollection(userId).doc(token).get();

      if (!sessionDoc.exists) {
        _logger.warning('Session with token/ID $token not found');
        return null;
      }

      final messagesSnapshot =
          await _getSessionMessagesCollection(
            userId,
            sessionDoc.id,
          ).orderBy('messageIndex').get();

      List<ChatMessage> messages =
          messagesSnapshot.docs.map((doc) {
            final data = doc.data();
            return ChatMessage(
              text: data['text'],
              isUser: data['isUser'],
              isSystem: data['isSystem'] ?? false,
              timestamp: (data['timestamp'] as Timestamp).toDate(),
            );
          }).toList();

      if (messages.isEmpty) {
        final sessionData = sessionDoc.data();
        if (sessionData?.containsKey('responses') == true) {
          final responses = sessionData!['responses'] as List?;
          if (responses != null && responses.isNotEmpty) {
            messages =
                responses.map((response) {
                  return ChatMessage(
                    text: response['text'] ?? '',
                    isUser: response['isUser'] ?? false,
                    isSystem: response['isSystem'] ?? false,
                    timestamp:
                        response['timestamp'] != null
                            ? (response['timestamp'] as Timestamp).toDate()
                            : DateTime.now(),
                  );
                }).toList();
          }
        }
      }

      final session = ChatSession.fromFirestore(sessionDoc, messages);
      _logger.info(
        'Successfully loaded session by token $token with ${messages.length} messages',
      );
      return session;
    } catch (e, stackTrace) {
      _logger.severe(
        'Error loading session by token $token: $e',
        e,
        stackTrace,
      );
      throw ChatSessionException('Failed to load session by token: $e');
    }
  }

  /// Repair session metadata
  Future<void> repairSessionMetadata(String userId, String sessionId) async {
    _logger.info('Repairing session metadata for $sessionId');
    try {
      final sessionRef = _getUserSessionsCollection(userId).doc(sessionId);
      final sessionDoc = await sessionRef.get();
      if (!sessionDoc.exists) {
        _logger.warning('Session $sessionId not found for repair');
        return;
      }
      final data = sessionDoc.data()!;
      final messagesSnapshot =
          await _getSessionMessagesCollection(
            userId,
            sessionId,
          ).orderBy('messageIndex').get();

      final messageCount = messagesSnapshot.docs.length;
      DateTime? lastMessageAt;
      if (messagesSnapshot.docs.isNotEmpty) {
        final lastMessageData = messagesSnapshot.docs.last.data();
        lastMessageAt = (lastMessageData['timestamp'] as Timestamp).toDate();
      }

      final updateData = <String, dynamic>{};
      if (data['name'] == null && data['autoGeneratedName'] == null) {
        updateData['name'] = 'Session ${sessionId.substring(0, 8)}';
      }
      if (data['topics'] == null || (data['topics'] as List).isEmpty) {
        updateData['topics'] = ['Untitled Topic'];
      }
      if (data['createdAt'] == null) {
        final firstMessageTimestamp =
            messagesSnapshot.docs.isNotEmpty
                ? (messagesSnapshot.docs.first.data()['timestamp'] as Timestamp)
                : Timestamp.fromDate(DateTime(2020, 1, 1));
        updateData['createdAt'] = firstMessageTimestamp;
      }
      if (data['updatedAt'] == null) {
        updateData['updatedAt'] =
            lastMessageAt != null
                ? Timestamp.fromDate(lastMessageAt)
                : (data['createdAt'] ?? Timestamp.fromDate(DateTime.now()));
      }
      if (data['messageCount'] == null) {
        updateData['messageCount'] = messageCount;
      }
      if (data['lastMessageAt'] == null && lastMessageAt != null) {
        updateData['lastMessageAt'] = Timestamp.fromDate(lastMessageAt);
      }
      if (data['state'] == null) {
        updateData['state'] = messageCount > 0 ? 'active' : 'initial';
      }
      if (data['isCompleted'] == null) {
        updateData['isCompleted'] = false;
      }
      if (data['token'] == null) {
        updateData['token'] = sessionId;
      }

      if (updateData.isNotEmpty) {
        await sessionRef.update(updateData);
        _logger.info(
          'Repaired session $sessionId with ${updateData.keys.length} missing fields',
        );
      } else {
        _logger.info(
          'Session $sessionId metadata is complete, no repair needed',
        );
      }
    } catch (e) {
      _logger.severe('Error repairing session $sessionId: $e');
    }
  }

  void _repairSessionsInBackground(String userId, List<String> sessionIds) {
    Future.delayed(Duration.zero, () async {
      for (final sessionId in sessionIds) {
        try {
          await repairSessionMetadata(userId, sessionId);
        } catch (e) {
          _logger.warning(
            'Background repair failed for session $sessionId: $e',
          );
        }
      }
    });
  }
}

/// Custom exception for chat session operations
class ChatSessionException implements Exception {
  final String message;
  final dynamic originalError;

  ChatSessionException(this.message, [this.originalError]);

  @override
  String toString() {
    return 'ChatSessionException: $message${originalError != null ? ' (caused by $originalError)' : ''}';
  }
}

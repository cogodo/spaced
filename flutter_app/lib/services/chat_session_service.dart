import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/chat_session.dart';
import '../screens/chat_screen.dart'; // For ChatMessage
import '../services/logger_service.dart';

/// Service for managing chat sessions in Firebase
///
/// IMPORTANT: Now unified with backend learning sessions!
///
/// This service now writes to 'users/{userId}/sessions' collection (same as backend)
/// instead of the legacy 'users/{userId}/chatSessions' collection.
///
/// This unifies:
/// - Frontend UI state (messages, tokens, chat metadata)
/// - Backend learning data (FSRS params, scoring, session progress)
///
/// Both frontend and backend now share the same session documents,
/// eliminating duplicate data and ensuring consistency.
class ChatSessionService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final _logger = getLogger('ChatSessionService');

  // Collection references
  CollectionReference<Map<String, dynamic>> _getUserSessionsCollection(
    String userId,
  ) {
    return _firestore.collection('users').doc(userId).collection('sessions');
  }

  CollectionReference<Map<String, dynamic>> _getSessionMessagesCollection(
    String userId,
    String sessionId,
  ) {
    return _getUserSessionsCollection(
      userId,
    ).doc(sessionId).collection('messages');
  }

  /// Save a chat session to Firebase with all required fields for history display
  Future<void> saveSession(String userId, ChatSession session) async {
    _logger.info('Saving session ${session.id} for user $userId');

    try {
      final batch = _firestore.batch();

      // Prepare session metadata with all required fields for history display
      final sessionData = {
        'token': session.id,
        'name': session.name,
        'autoGeneratedName': session.autoGeneratedName,
        'topics': session.topics,
        'state': session.state.name,
        'finalScores': session.finalScores,
        'createdAt': Timestamp.fromDate(session.createdAt),
        'updatedAt': Timestamp.fromDate(session.updatedAt),
        'isCompleted': session.isCompleted,
        'messageCount': session.messageCount,
        'lastMessageAt':
            session.lastMessageAt != null
                ? Timestamp.fromDate(session.lastMessageAt!)
                : (session.messages.isNotEmpty
                    ? Timestamp.fromDate(session.messages.last.timestamp)
                    : null),
      };

      // Update session metadata
      final sessionRef = _getUserSessionsCollection(userId).doc(session.id);
      batch.set(sessionRef, sessionData, SetOptions(merge: true));

      // Clear existing messages first to prevent duplicates
      final messagesCollection = _getSessionMessagesCollection(
        userId,
        session.id,
      );

      // Get existing messages to delete them
      final existingMessages = await messagesCollection.get();
      for (final doc in existingMessages.docs) {
        batch.delete(doc.reference);
      }

      // Save current messages with consistent naming
      for (int i = 0; i < session.messages.length; i++) {
        final message = session.messages[i];
        final messageData = {
          'text': message.text,
          'isUser': message.isUser,
          'isSystem': message.isSystem,
          'timestamp': Timestamp.fromDate(message.timestamp),
          'messageIndex': i,
        };

        final messageRef = messagesCollection.doc('msg_$i');
        batch.set(
          messageRef,
          messageData,
        ); // Use set without merge to ensure clean save
      }

      await batch.commit();
      _logger.info(
        'Successfully saved session ${session.id} with ${session.messages.length} messages',
      );
    } catch (e, stackTrace) {
      _logger.severe('Error saving session ${session.id}: $e', e, stackTrace);
      throw ChatSessionException('Failed to save session: $e');
    }
  }

  /// Load a specific chat session from Firestore
  Future<ChatSession?> loadSession(String userId, String sessionId) async {
    _logger.info('Loading session $sessionId for user $userId');

    try {
      // Get session metadata
      final sessionDoc =
          await _getUserSessionsCollection(userId).doc(sessionId).get();

      if (!sessionDoc.exists) {
        _logger.warning('Session $sessionId not found');
        return null;
      }

      // Get session messages
      final messagesSnapshot =
          await _getSessionMessagesCollection(
            userId,
            sessionId,
          ).orderBy('messageIndex').get();

      final messages =
          messagesSnapshot.docs.map((doc) {
            final data = doc.data();
            return ChatMessage(
              text: data['text'],
              isUser: data['isUser'],
              isSystem: data['isSystem'] ?? false,
              timestamp: (data['timestamp'] as Timestamp).toDate(),
            );
          }).toList();

      final session = ChatSession.fromFirestore(sessionDoc, messages);
      _logger.info(
        'Successfully loaded session $sessionId with ${messages.length} messages',
      );
      return session;
    } catch (e, stackTrace) {
      _logger.severe('Error loading session $sessionId: $e', e, stackTrace);
      throw ChatSessionException('Failed to load session: $e');
    }
  }

  /// Get session history summaries for a user
  Future<List<ChatSessionSummary>> getSessionHistory(
    String userId, {
    int limit = 50,
    DocumentSnapshot? startAfter,
  }) async {
    _logger.info('Loading session history for user $userId (limit: $limit)');

    try {
      // Use updatedAt for ordering since it's more likely to exist on all sessions
      Query<Map<String, dynamic>> query = _getUserSessionsCollection(
        userId,
      ).orderBy('updatedAt', descending: true).limit(limit);

      if (startAfter != null) {
        query = query.startAfterDocument(startAfter);
      }

      var snapshot = await query.get();

      final sessions = <ChatSessionSummary>[];
      final sessionsNeedingRepair = <String>[];

      for (final doc in snapshot.docs) {
        try {
          final data = doc.data();

          // Check if session needs repair (missing critical fields)
          final needsRepair =
              data['name'] == null && data['autoGeneratedName'] == null ||
              data['topics'] == null ||
              data['messageCount'] == null;

          if (needsRepair) {
            sessionsNeedingRepair.add(doc.id);
          }

          final session = ChatSessionSummary.fromFirestore(doc);
          sessions.add(session);
        } catch (e, stackTrace) {
          _logger.warning('Error parsing session ${doc.id}: $e');

          // If parsing failed, definitely needs repair
          sessionsNeedingRepair.add(doc.id);
        }
      }

      // Repair sessions that need it (run in background)
      if (sessionsNeedingRepair.isNotEmpty) {
        _repairSessionsInBackground(userId, sessionsNeedingRepair);
      }

      _logger.info('Loaded ${sessions.length} session summaries');
      return sessions;
    } catch (e, stackTrace) {
      _logger.severe('Error loading session history: $e', e, stackTrace);
      throw ChatSessionException('Failed to load session history: $e');
    }
  }

  /// Delete a chat session and all its messages
  Future<void> deleteSession(String userId, String sessionId) async {
    _logger.info('Deleting session $sessionId for user $userId');

    try {
      final batch = _firestore.batch();

      // Delete all messages
      final messagesSnapshot =
          await _getSessionMessagesCollection(userId, sessionId).get();
      for (final doc in messagesSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Delete session document
      final sessionRef = _getUserSessionsCollection(userId).doc(sessionId);
      batch.delete(sessionRef);

      await batch.commit();
      _logger.info('Successfully deleted session $sessionId');
    } catch (e, stackTrace) {
      _logger.severe('Error deleting session $sessionId: $e', e, stackTrace);
      throw ChatSessionException('Failed to delete session: $e');
    }
  }

  /// Save a single message to an existing session
  Future<void> saveMessage(
    String userId,
    String sessionId,
    ChatMessage message,
    int messageIndex,
  ) async {
    try {
      final messageRef = _getSessionMessagesCollection(userId, sessionId).doc();

      await messageRef.set({
        'text': message.text,
        'isUser': message.isUser,
        'isSystem': message.isSystem,
        'timestamp': Timestamp.fromDate(message.timestamp),
        'messageIndex': messageIndex,
      });

      // Update session metadata
      await _getUserSessionsCollection(userId).doc(sessionId).update({
        'updatedAt': Timestamp.fromDate(DateTime.now()),
        'lastMessageAt': Timestamp.fromDate(message.timestamp),
        'messageCount': FieldValue.increment(1),
      });

      _logger.info('Saved message to session $sessionId');
    } catch (e, stackTrace) {
      _logger.severe(
        'Error saving message to session $sessionId: $e',
        e,
        stackTrace,
      );
      throw ChatSessionException('Failed to save message: $e');
    }
  }

  /// Load messages for a specific session
  Future<List<ChatMessage>> loadMessages(
    String userId,
    String sessionId,
  ) async {
    try {
      final snapshot =
          await _getSessionMessagesCollection(
            userId,
            sessionId,
          ).orderBy('messageIndex').get();

      final messages =
          snapshot.docs.map((doc) {
            final data = doc.data();
            return ChatMessage(
              text: data['text'],
              isUser: data['isUser'],
              isSystem: data['isSystem'] ?? false,
              timestamp: (data['timestamp'] as Timestamp).toDate(),
            );
          }).toList();

      _logger.info('Loaded ${messages.length} messages for session $sessionId');
      return messages;
    } catch (e, stackTrace) {
      _logger.severe(
        'Error loading messages for session $sessionId: $e',
        e,
        stackTrace,
      );
      throw ChatSessionException('Failed to load messages: $e');
    }
  }

  /// Update session name
  Future<void> updateSessionName(
    String userId,
    String sessionId,
    String newName, {
    bool isAutoGenerated = false,
  }) async {
    _logger.info('Updating session $sessionId name to: $newName');

    try {
      final updateData = <String, dynamic>{
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      };

      if (isAutoGenerated) {
        updateData['autoGeneratedName'] = newName;
      } else {
        updateData['name'] = newName;
      }

      await _getUserSessionsCollection(
        userId,
      ).doc(sessionId).update(updateData);
      _logger.info('Successfully updated session $sessionId name');
    } catch (e, stackTrace) {
      _logger.severe(
        'Error updating session $sessionId name: $e',
        e,
        stackTrace,
      );
      throw ChatSessionException('Failed to update session name: $e');
    }
  }

  /// Update session state
  Future<void> updateSessionState(
    String userId,
    String sessionId,
    SessionState state, {
    Map<String, int>? finalScores,
  }) async {
    try {
      final updateData = {
        'state': state.name,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
        'isCompleted': state == SessionState.completed,
      };

      if (finalScores != null) {
        updateData['finalScores'] = finalScores;
      }

      await _getUserSessionsCollection(
        userId,
      ).doc(sessionId).update(updateData);
      _logger.info('Updated session $sessionId state to ${state.name}');
    } catch (e, stackTrace) {
      _logger.severe(
        'Error updating session $sessionId state: $e',
        e,
        stackTrace,
      );
      throw ChatSessionException('Failed to update session state: $e');
    }
  }

  /// Search sessions by name or topics
  Future<List<ChatSessionSummary>> searchSessions(
    String userId,
    String query, {
    int limit = 20,
  }) async {
    _logger.info('Searching sessions for user $userId with query: $query');

    try {
      // Note: Firestore doesn't support full-text search, so we'll implement
      // a simple name-based search. For production, consider using Algolia or similar.
      final snapshot =
          await _getUserSessionsCollection(userId)
              .where('name', isGreaterThanOrEqualTo: query)
              .where('name', isLessThan: query + '\uf8ff')
              .limit(limit)
              .get();

      final sessions =
          snapshot.docs
              .map((doc) {
                try {
                  return ChatSessionSummary.fromFirestore(doc);
                } catch (e) {
                  _logger.warning('Error parsing session ${doc.id}: $e');
                  return null;
                }
              })
              .where((session) => session != null)
              .cast<ChatSessionSummary>()
              .toList();

      _logger.info('Found ${sessions.length} sessions matching query');
      return sessions;
    } catch (e, stackTrace) {
      _logger.severe('Error searching sessions: $e', e, stackTrace);
      throw ChatSessionException('Failed to search sessions: $e');
    }
  }

  /// Get sessions by state (active, completed, etc.)
  Future<List<ChatSessionSummary>> getSessionsByState(
    String userId,
    SessionState state, {
    int limit = 20,
  }) async {
    try {
      final snapshot =
          await _getUserSessionsCollection(userId)
              .where('state', isEqualTo: state.name)
              .orderBy('createdAt', descending: true)
              .limit(limit)
              .get();

      final sessions =
          snapshot.docs
              .map((doc) {
                try {
                  return ChatSessionSummary.fromFirestore(doc);
                } catch (e) {
                  _logger.warning('Error parsing session ${doc.id}: $e');
                  return null;
                }
              })
              .where((session) => session != null)
              .cast<ChatSessionSummary>()
              .toList();

      _logger.info('Found ${sessions.length} sessions in state ${state.name}');
      return sessions;
    } catch (e, stackTrace) {
      _logger.severe('Error getting sessions by state: $e', e, stackTrace);
      throw ChatSessionException('Failed to get sessions by state: $e');
    }
  }

  /// Check if user has any incomplete sessions
  Future<List<ChatSessionSummary>> getIncompleteSessions(String userId) async {
    _logger.info('Checking for incomplete sessions for user $userId');

    try {
      final activeSessionsQuery = _getUserSessionsCollection(userId)
          .where('isCompleted', isEqualTo: false)
          .orderBy('createdAt', descending: true);

      final snapshot = await activeSessionsQuery.get();

      final sessions =
          snapshot.docs
              .map((doc) {
                try {
                  return ChatSessionSummary.fromFirestore(doc);
                } catch (e) {
                  _logger.warning('Error parsing session ${doc.id}: $e');
                  return null;
                }
              })
              .where((session) => session != null)
              .cast<ChatSessionSummary>()
              .toList();

      _logger.info('Found ${sessions.length} incomplete sessions');
      return sessions;
    } catch (e, stackTrace) {
      _logger.severe('Error getting incomplete sessions: $e', e, stackTrace);
      throw ChatSessionException('Failed to get incomplete sessions: $e');
    }
  }

  /// Stream session updates for real-time sync
  Stream<List<ChatSessionSummary>> watchSessionHistory(
    String userId, {
    int limit = 50,
  }) {
    return _getUserSessionsCollection(userId)
        .orderBy('createdAt', descending: true)
        .limit(limit)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) {
                try {
                  return ChatSessionSummary.fromFirestore(doc);
                } catch (e) {
                  _logger.warning('Error parsing session ${doc.id}: $e');
                  return null;
                }
              })
              .where((session) => session != null)
              .cast<ChatSessionSummary>()
              .toList();
        });
  }

  /// Load a specific chat session from Firestore by token
  Future<ChatSession?> loadSessionByToken(String userId, String token) async {
    _logger.info('Loading session by token: $token for user $userId');

    try {
      // Since token is now the session ID, get document directly
      final sessionDoc =
          await _getUserSessionsCollection(userId).doc(token).get();

      if (!sessionDoc.exists) {
        _logger.warning('Session with token/ID $token not found');
        return null;
      }

      // Get session messages
      final messagesSnapshot =
          await _getSessionMessagesCollection(
            userId,
            sessionDoc.id,
          ).orderBy('messageIndex').get();

      List<ChatMessage> messages =
          messagesSnapshot.docs.map((doc) {
            final data = doc.data();
            return ChatMessage(
              text: data['text'],
              isUser: data['isUser'],
              isSystem: data['isSystem'] ?? false,
              timestamp: (data['timestamp'] as Timestamp).toDate(),
            );
          }).toList();

      // Fallback: check for legacy 'responses' array if no messages in subcollection
      if (messages.isEmpty) {
        final sessionData = sessionDoc.data();
        if (sessionData?.containsKey('responses') == true) {
          final responses = sessionData!['responses'] as List?;

          if (responses != null && responses.isNotEmpty) {
            messages =
                responses.map((response) {
                  return ChatMessage(
                    text: response['text'] ?? '',
                    isUser: response['isUser'] ?? false,
                    isSystem: response['isSystem'] ?? false,
                    timestamp:
                        response['timestamp'] != null
                            ? (response['timestamp'] as Timestamp).toDate()
                            : DateTime.now(),
                  );
                }).toList();
          }
        }
      }

      final session = ChatSession.fromFirestore(sessionDoc, messages);
      _logger.info(
        'Successfully loaded session by token $token with ${messages.length} messages',
      );
      return session;
    } catch (e, stackTrace) {
      _logger.severe(
        'Error loading session by token $token: $e',
        e,
        stackTrace,
      );
      throw ChatSessionException('Failed to load session by token: $e');
    }
  }

  /// Repair session metadata by back-populating missing fields
  /// This is useful for sessions created before comprehensive metadata saving
  Future<void> repairSessionMetadata(String userId, String sessionId) async {
    _logger.info('Repairing session metadata for $sessionId');

    try {
      // Get the session document
      final sessionRef = _getUserSessionsCollection(userId).doc(sessionId);
      final sessionDoc = await sessionRef.get();

      if (!sessionDoc.exists) {
        _logger.warning('Session $sessionId not found for repair');
        return;
      }

      final data = sessionDoc.data()!;

      // Get messages from subcollection to calculate metadata
      final messagesSnapshot =
          await _getSessionMessagesCollection(
            userId,
            sessionId,
          ).orderBy('messageIndex').get();

      final messageCount = messagesSnapshot.docs.length;
      DateTime? lastMessageAt;

      if (messagesSnapshot.docs.isNotEmpty) {
        final lastMessageData = messagesSnapshot.docs.last.data();
        lastMessageAt = (lastMessageData['timestamp'] as Timestamp).toDate();
      }

      // Prepare update data with missing fields
      final updateData = <String, dynamic>{};

      // Add missing name if not present
      if (data['name'] == null && data['autoGeneratedName'] == null) {
        updateData['name'] = 'Session ${sessionId.substring(0, 8)}';
      }

      // Add missing topics if not present
      if (data['topics'] == null || (data['topics'] as List).isEmpty) {
        updateData['topics'] = ['Untitled Topic'];
      }

      // Add missing timestamps
      if (data['createdAt'] == null) {
        // Use message timestamp or fallback to old date
        final firstMessageTimestamp =
            messagesSnapshot.docs.isNotEmpty
                ? (messagesSnapshot.docs.first.data()['timestamp'] as Timestamp)
                : Timestamp.fromDate(DateTime(2020, 1, 1));
        updateData['createdAt'] = firstMessageTimestamp;
      }

      if (data['updatedAt'] == null) {
        updateData['updatedAt'] =
            lastMessageAt != null
                ? Timestamp.fromDate(lastMessageAt)
                : (data['createdAt'] ?? Timestamp.fromDate(DateTime.now()));
      }

      // Add missing message metadata
      if (data['messageCount'] == null) {
        updateData['messageCount'] = messageCount;
      }

      if (data['lastMessageAt'] == null && lastMessageAt != null) {
        updateData['lastMessageAt'] = Timestamp.fromDate(lastMessageAt);
      }

      // Add missing state
      if (data['state'] == null) {
        updateData['state'] = messageCount > 0 ? 'active' : 'initial';
      }

      // Add missing completion status
      if (data['isCompleted'] == null) {
        updateData['isCompleted'] = false;
      }

      // Add missing token (should be session ID)
      if (data['token'] == null) {
        updateData['token'] = sessionId;
      }

      // Update the document if we have any repairs to make
      if (updateData.isNotEmpty) {
        await sessionRef.update(updateData);
        _logger.info(
          'Repaired session $sessionId with ${updateData.keys.length} missing fields',
        );
      } else {
        _logger.info(
          'Session $sessionId metadata is complete, no repair needed',
        );
      }
    } catch (e, stackTrace) {
      _logger.severe('Error repairing session $sessionId: $e', e, stackTrace);
    }
  }

  /// Batch repair all sessions for a user
  Future<void> repairAllUserSessions(String userId) async {
    _logger.info('Starting batch repair for all sessions of user $userId');

    try {
      final snapshot = await _getUserSessionsCollection(userId).get();
      _logger.info(
        'Found ${snapshot.docs.length} sessions to potentially repair',
      );

      for (final doc in snapshot.docs) {
        await repairSessionMetadata(userId, doc.id);
      }

      _logger.info('Completed batch repair for user $userId');
    } catch (e, stackTrace) {
      _logger.severe(
        'Error in batch repair for user $userId: $e',
        e,
        stackTrace,
      );
    }
  }

  /// Repair sessions in background (non-blocking)
  void _repairSessionsInBackground(String userId, List<String> sessionIds) {
    // Don't await - run in background
    Future.delayed(Duration.zero, () async {
      for (final sessionId in sessionIds) {
        try {
          await repairSessionMetadata(userId, sessionId);
        } catch (e) {
          _logger.warning(
            'Background repair failed for session $sessionId: $e',
          );
        }
      }
    });
  }
}

/// Custom exception for chat session operations
class ChatSessionException implements Exception {
  final String message;
  final dynamic originalError;

  ChatSessionException(this.message, [this.originalError]);

  @override
  String toString() {
    return 'ChatSessionException: $message${originalError != null ? ' (caused by $originalError)' : ''}';
  }
}

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class TurnState(str, Enum):
    # The system is waiting for the user's initial answer to a question
    AWAITING_INITIAL_ANSWER = "AWAITING_INITIAL_ANSWER"
    # The system is waiting for the user's response to feedback/hint
    AWAITING_FOLLOW_UP = "AWAITING_FOLLOW_UP"
    # The system has evaluated the user and is asking them what to do next
    AWAITING_NEXT_ACTION = "AWAITING_NEXT_ACTION"


class SessionState(str, Enum):
    """Frontend session state for UI flow"""

    INITIAL = "initial"
    SELECTING_SESSION_TYPE = "selectingSessionType"
    SELECTING_DUE_TOPICS = "selectingDueTopics"
    COLLECTING_TOPICS = "collectingTopics"
    ACTIVE = "active"
    COMPLETED = "completed"
    ERROR = "error"


class Session(BaseModel):
    """
    Unified session model combining Context (backend learning) and ChatSession (frontend UI) data.
    This replaces both Context and ChatSession to eliminate duplication.
    """

    # Core identification
    id: str = Field(..., description="Unique identifier for the session (same as chatId)")
    userUid: str = Field(..., description="User ID of the owner")

    # UI metadata
    name: str = Field(default="New Session", description="User-defined session name")
    autoGeneratedName: Optional[str] = Field(None, description="Auto-generated descriptive name")

    # Learning content
    topics: List[str] = Field(default_factory=list, description="List of topic names")
    topicId: str = Field(..., description="The primary topic ID being studied")
    questionIds: List[str] = Field(default_factory=list, description="List of question IDs for the session")
    questionIdx: int = Field(0, description="Index of the current question")
    scores: Dict[str, int] = Field(default_factory=dict, description="Scores for each question (questionId -> score)")

    # Session state management
    state: SessionState = Field(SessionState.INITIAL, description="Frontend UI state")
    turnState: TurnState = Field(TurnState.AWAITING_INITIAL_ANSWER, description="Backend learning turn state")
    initialScore: Optional[int] = Field(None, description="Score of the user's first attempt on current question")

    # Completion and analytics
    isCompleted: bool = Field(False, description="Whether the session is completed")
    finalScores: Optional[Dict[str, int]] = Field(None, description="Final scores when session completes")
    messageCount: int = Field(0, description="Number of messages in the session")

    # Timestamps
    startedAt: datetime = Field(default_factory=datetime.utcnow, description="Session start time")
    createdAt: datetime = Field(default_factory=datetime.utcnow, description="Session creation time")
    updatedAt: datetime = Field(default_factory=datetime.utcnow, description="Last update time")
    endedAt: Optional[datetime] = Field(None, description="Session end time")
    lastMessageAt: Optional[datetime] = Field(None, description="Timestamp of last message")

    def end_session(self):
        """Mark session as ended"""
        self.endedAt = datetime.utcnow()
        self.isCompleted = True
        self.state = SessionState.COMPLETED

    def touch(self):
        """Update the updatedAt timestamp"""
        self.updatedAt = datetime.utcnow()

    def to_context_dict(self) -> dict:
        """Convert to Context-compatible dict for backward compatibility"""
        return {
            "chatId": self.id,  # Use id directly
            "userUid": self.userUid,
            "topicId": self.topicId,
            "questionIds": self.questionIds,
            "questionIdx": self.questionIdx,
            "scores": self.scores,
            "startedAt": self.startedAt,
            "endedAt": self.endedAt,
            "updatedAt": self.updatedAt,
            "turnState": self.turnState.value,
            "initialScore": self.initialScore,
        }

    def to_frontend_dict(self) -> dict:
        """Convert to frontend ChatSession-compatible dict"""
        return {
            "id": self.id,
            "token": self.id,  # Use id directly
            "name": self.name,
            "autoGeneratedName": self.autoGeneratedName,
            "topics": self.topics,
            "topicId": self.topicId,
            "state": self.state.value,
            "finalScores": self.finalScores,
            "createdAt": self.createdAt,
            "updatedAt": self.updatedAt,
            "isCompleted": self.isCompleted,
            "messageCount": self.messageCount,
            "lastMessageAt": self.lastMessageAt,
        }

    model_config = {"from_attributes": True}
